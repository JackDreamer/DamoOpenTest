package com.dhc.jstestdemo.algorithmanalysis;

import android.os.SystemClock;
import android.util.Log;

/**
 * 排序算法，包括桶排序，冒泡排序，快速排序
 * Created by 大漠dreamer on 2019/3/26.
 */

public class SortTest {

    private static final String TAG = SortTest.class.getSimpleName();
    private int[] array = {3, 1, 3, 6, 8, 3, 9, 10, 8, 7, 7, 7};

    public SortTest() {

    }

    /**
     * 桶排序
     */
    public void bucketSort() {

        //排序的数字为0-10的数字，则创建一个长度为11的集合，其中的原始均为0
        int[] initArray = new int[11];
        //首先给集合赋初始值
        for (int i = 0; i < initArray.length; i++) {
            initArray[i] = 0;
        }
        int temp;
        //循环读取array的数值，数值为几，则将对应的数字的脚标+1，如果出现重复，则对应的长度+1
        for (int i = 0; i < array.length; i++) {
            temp = array[i];
            initArray[temp]++;

        }
        synchronized (this) {
            //遍历新的集合
            for (int i = 0; i < initArray.length; i++) {
                //出现了几次就打印几次
                for (int j = 1; j <= initArray[i]; j++) {
                    //这里sleep 0.5S的原因，就是防止程序运行太快，导致异步数据没有加载出来
                    SystemClock.sleep(500);
                    Log.d(TAG, "bucketSort: " + i);
                }
            }
        }
    }

    /**
     * 冒泡排序
     */

    public void bubbleSort() {

        //第一遍遍历集合
        for (int i = 1; i < array.length; i++) {
            //第二遍遍历给集合重新赋值
            for (int j = 1; j < array.length - i; j++) {
                //判断前面的数是否比后面大，大就交换位置
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        for (int i = 1; i < array.length; i++) {
            SystemClock.sleep(2000);
            Log.d(TAG, "bubbleSort: " + array[i]);
        }
    }

    /**
     * 快速排序
     * 基础原理：
     * 取第一个数作为基准数，然后从两头（两个哨兵）开始处理，
     * 当左边的比右边的大时（哨兵没有相遇），互相交换位置，直到交换完毕，
     * 此时可以找到中间数作为基准数，将此数归位
     * 然后把数列分为两部分，继续比较
     */
    private void quicklySort(int left, int right) {

        int base, i, j, temp;
        if (left > right) {
            return;
        }
        //以左边的数作为基准线
        base = array[left];

        i = left;
        j = right;

        while (i != j) {
            //先从右往左找
            while (array[j] >= base && i < j) {
                j--;
            }
            //然后从左往右找,注意一定要加上等于基准数
            while (array[i] <= base && i < j) {
                i++;
            }
            //当两个哨兵没有相遇时，则交换位置
            if (i < j) {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        //将基准线归位
        array[left] = array[i];
        array[i] = base;
        //继续比较基准线两边的数
        //比较左边的数
        quicklySort(left, i - 1);
        //比较右边的数
        quicklySort(i + 1, right);
    }

    /**
     * 快速排序测试
     */
    public void quickLySortTest() {
        quicklySort(0, array.length-1);
        synchronized (this) {
            for (int i = 0; i < array.length; i++) {
                SystemClock.sleep(500);
                Log.d(TAG, "quickLySortTest: " + array[i]);
            }
        }
    }
}
