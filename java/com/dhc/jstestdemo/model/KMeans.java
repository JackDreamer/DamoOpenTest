package com.dhc.jstestdemo.model;

import android.util.Log;

import java.util.ArrayList;
import java.util.List;

/**
 * K-means算法解析
 * Created by 大漠dreamer on 2018/11/26.
 */

public class KMeans {

    /**
     * 需要一个集合来存放原始坐标
     */
    List<Point> original = null;
    Point point1 = null;
    Point point2 = null;
    Point point3 = null;
    Point point4 = null;

    Point point5 = null;
    Point point6 = null;
    Point point7 = null;
    Point point8 = null;

    /**
     * 3个新的聚类
     */
    List<Point> list1 = null;
    List<Point> list2 = null;
    List<Point> list3 = null;

    Point basePointOne = null;
    Point basePointTwo = null;
    Point basePointThree = null;

    /**
     * 聚类计算的次数
     */
    private static final int calculatorNumber = 5;
    private int calculator = 0;

    /**
     * 构造函数，可以根据自己的要求，来定制化需要进行聚类的点
     * 这里例子采用的是8个点， 3个初始化基准点的方法，最终计算十次之后来确定聚类
     */
    public KMeans() {
    }

    /**
     * 初始化
     * 这里例子采用的是8个点， 3个初始化基准点的方法，最终来确定聚类
     */
    public void initData() {
        original = new ArrayList<>();
        list1 = new ArrayList<>();
        list2 = new ArrayList<>();
        list3 = new ArrayList<>();


        point1 = new Point(1.0, 2.0);
        original.add(point1);
        point2 = new Point(4.0, 8.0);
        original.add(point2);
        point3 = new Point(3.0, 5.0);
        original.add(point3);
        point4 = new Point(2.0, 6.0);
        original.add(point4);

        point5 = new Point(10.0, 2.0);
        original.add(point5);
        point6 = new Point(8.0, 1.0);
        original.add(point6);
        point7 = new Point(3.0, 6.0);
        original.add(point7);
        point8 = new Point(16.0, 9.0);
        original.add(point8);

        //选取初始点，分别计算曼哈顿聚类距离，此处选取1,4,7为初始点
        basePointOne = point1;
        basePointTwo = point4;
        basePointThree = point7;
    }


    /**
     * 计算点到基准点的距离，并将数据添加到对应的集合中
     *
     * @param point
     */
    private void setPointToCluster(Point point) {

        Double distanceForOneToOne = ManHaDunDistance(point, basePointOne);
        Double distanceForOneToFour = ManHaDunDistance(point, basePointTwo);
        Double distanceForOneToSeven = ManHaDunDistance(point, basePointThree);

        Double compareOne = Math.min(distanceForOneToOne, distanceForOneToFour);
        Double compareTwo = Math.min(compareOne, distanceForOneToSeven);

        //TODO 此处有可能有问题，如果出现除不尽的，怎么办？
        if (compareTwo.equals(distanceForOneToOne)) {
            list1.add(point);
        } else if (compareTwo.equals(distanceForOneToFour)) {
            list2.add(point);
        } else {
            list3.add(point);
        }
    }

    /**
     * 计算下一个聚类，
     */
    public void getNextBasePointAndUpdateCluster() {


        calculator++;
        /**
         * 当递归次数已经到达限制次数之后，不再进行递归运算，计算停止
         */
        if (calculator == calculatorNumber) {
            return;
        }
        /**
         *  每次计算聚类的时候，清除上一次的聚类数据
         */
        if (list1 != null) {
            list1.clear();
        }
        if (list2 != null) {
            list2.clear();
        }
        if (list3 != null) {
            list3.clear();
        }

        setPointToCluster(point1);
        setPointToCluster(point2);
        setPointToCluster(point3);
        setPointToCluster(point4);
        setPointToCluster(point5);
        setPointToCluster(point6);
        setPointToCluster(point7);
        setPointToCluster(point8);

        basePointOne = new Point(getAverage(list1, true), getAverage(list1, false));
        basePointTwo = new Point(getAverage(list2, true), getAverage(list2, false));
        basePointThree = new Point(getAverage(list3, true), getAverage(list3, false));

        /**
         * 递归继续算下一个点和聚类
         */
        getNextBasePointAndUpdateCluster();

    }

    /**
     * 计算数字的加权平均值
     */
    private Double getAverage(List<Point> list, boolean isX) {

        Double sum = 0.0;

        for (int i = 0; i < list.size(); i++) {
            if (isX) {
                sum = sum + list.get(i).getX();
            } else {
                sum = sum + list.get(i).getY();
            }
        }

        return sum / list.size();
    }

    /**
     * 曼哈顿聚类距离
     */
    private Double ManHaDunDistance(Point pointOne, Point pointTwo) {

        return Math.abs(pointTwo.getX() - pointOne.getX()) +
                Math.abs(pointTwo.getY() - pointOne.getY());
    }


    public void typeList() {
        for (int i = 0; i < list1.size(); i++) {
            Point point = list1.get(i);
            int index = original.indexOf(point);
            Log.d("cluster", "我来自聚类1----横坐标为：" + point.getX()
                    + "纵坐标为：" + point.getY() +
                    "位于原始集合里面的：" + (index + 1) + "位置");
        }
        for (int i = 0; i < list2.size(); i++) {
            Point point = list2.get(i);
            int index = original.indexOf(point);
            Log.d("cluster", "我来自聚类2----横坐标为：" + point.getX()
                    + "纵坐标为：" + point.getY() +
                    "位于原始集合里面的：" + (index + 1) + "位置");
        }
        for (int i = 0; i < list3.size(); i++) {
            Point point = list3.get(i);
            int index = original.indexOf(point);
            Log.d("cluster", "我来自聚类3----横坐标为：" + point.getX()
                    + "纵坐标为：" + point.getY() +
                    "位于原始集合里面的：" + (index + 1) + "位置");
        }

        Log.d("cluster", "第一个基准点的横坐标：" + basePointOne.getX()
                + "第一个基准点的纵坐标坐标：" + basePointOne.getY());
        Log.d("cluster", "第二个基准点的横坐标：" + basePointTwo.getX()
                + "第二个基准点的纵坐标坐标：" + basePointTwo.getY());
        Log.d("cluster", "第三个基准点的横坐标：" + basePointThree.getX()
                + "第三个基准点的纵坐标坐标：" + basePointThree.getY());
    }

    /**
     * 坐标类
     */
    class Point {

        Double x;
        Double y;

        public Point(Double x, Double y) {
            this.x = x;
            this.y = y;
        }

        public Double getX() {
            return x;
        }

        public void setX(Double x) {
            this.x = x;
        }

        public Double getY() {
            return y;
        }

        public void setY(Double y) {
            this.y = y;
        }
    }
}
