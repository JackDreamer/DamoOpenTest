package com.dhc.jstestdemo.lock;

import android.util.Log;

import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by 大漠dreamer on 2019/3/20.
 */

public class LockTest {

    public static final String TAG = LockTest.class.getSimpleName();

    //创建锁
    private ReentrantLock mLock;


    public LockTest() {
    }

    private LockTest(ReentrantLock mLock) {
        this.mLock = mLock;
    }

    /**
     * 设置锁
     */
    private void setLock(ReentrantLock lock) {
        try {
            lock.lock();
            if (lock.isFair()) {
                Log.d(TAG, "setFairLock: " + Thread.currentThread().getName() + "get Fair Lock");

            } else {
                Log.d(TAG, "setFairLock:" + Thread.currentThread().getName() + " get Unfair Lock");
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    /**
     * 测试锁
     *
     * @param lock
     */
    private void testLock(final ReentrantLock lock) {


        final LockTest fairLock = new LockTest(lock);

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                Log.d(TAG, "run: " + Thread.currentThread().getName() + "running");
                fairLock.setLock(lock);
            }
        };

        Thread[] threads = new Thread[5];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(runnable);
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
    }

    public void test() {
        testLock(new ReentrantLock(true));
        testLock(new ReentrantLock(false));
    }
}
